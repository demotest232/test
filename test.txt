 // Compute added, removed, modified sets by path
    Set<String> added = new HashSet<>(shaInTag2.keySet());
    added.removeAll(shaInTag1.keySet());
    Set<String> removed = new HashSet<>(shaInTag1.keySet());
    removed.removeAll(shaInTag2.keySet());
    Set<String> modified = shaInTag1.keySet().stream()
        .filter(shaInTag2::containsKey)
        .filter(p -> !Objects.equals(shaInTag1.get(p), shaInTag2.get(p)))
        .collect(Collectors.toSet());

    // Recreate your GitLab-style path treatment
    for (String path : added) {
        if (path.contains("Packages")) {
            // Skip, do nothing (exclude entirely)
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            // mimic substring(19) logic if needed; careful with short paths
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }

        // Files added
        if (filesAdded != null) {
            if (path.length() > 19) {
                filesAdded.add(String.valueOf(path.substring(19)));
            } else {
                filesAdded.add(String.valueOf(path));
            }
        }
    }

    for (String path : modified) {
        if (path.contains("Packages")) {
            // Do nothing
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }
    }

    for (String path : removed) {
        if (path.contains("Packages")) {
            // Do nothing
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }
    }
