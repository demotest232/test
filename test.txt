Set<String> added = new HashSet<>(shaInTag2.keySet());
    added.removeAll(shaInTag1.keySet());
    Set<String> removed = new HashSet<>(shaInTag1.keySet());
    removed.removeAll(shaInTag2.keySet());
    Set<String> modified = shaInTag1.keySet().stream()
        .filter(shaInTag2::containsKey)
        .filter(p -> !Objects.equals(shaInTag1.get(p), shaInTag2.get(p)))
        .collect(Collectors.toSet());

    // Prepare excludedFolders predicate
    Predicate<String> notExcluded = path -> {
        if (excludedFolders != null) {
            for (String folder : excludedFolders) {
                if (path.contains(folder)) return false;
            }
        }
        return true;
    };

    // Process (added, removed, modified) with all exclusion logic
    for (String path : added) {
        if (!notExcluded.test(path)) continue; // Apply excludedFolders filter
        if (path.contains("Packages")) {
            // Skip, do nothing
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }
        if (filesAdded != null) {
            filesAdded.add(path.length() > 19 ? path.substring(19) : path);
        }
    }
    for (String path : modified) {
        if (!notExcluded.test(path)) continue;
        if (path.contains("Packages")) {
            // Skip
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }
    }
    for (String path : removed) {
        if (!notExcluded.test(path)) continue;
        if (path.contains("Packages")) {
            // Skip
        } else if (path.contains("Grants")) {
            filesModified.add(path);
        } else {
            filesModified.add(path.length() > 19 ? path.substring(19) : path);
        }
    }
